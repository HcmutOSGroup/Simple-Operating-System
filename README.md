# OS_assignment_demo
Simple Operating System

Complete most primitive function of an Operating System
# Update_description_for_details
* Header files <br/>
    – timer.h: Define the timer for the whole system.<br/>
    - cpu.h: Define functions used to implement the virtual CPU. <br/>
    - queue.h: Functions used to implement queue which holds the PCB of processes. <br/>
    - sched.h: Define functions used by the scheduler. <br/>
    - mem.h: Functions used by Virtual Memory Engine. <br/>
    - loader.h: Functions used by the loader which load the program from disk to memory. <br/>
    - common.h: Define structs and functions used everywhere in the OS. <br/>
    - bitopts.h: Define operations on bit data. <br/>
    - os-mm.h, mm.h: Define the structure and basic data for Paging-based Memory Management. <br/>
    - os-cfg.h: (Optional) Define contants use to switch the software configuration. <br/>
* Source files <br/>
  -  timer.c: Implement the timer.
  -  cpu.c: Implement the virtual CPU.<br/>
  -  queue.c: Implement operations on (priority) queues.<br/>
  -  paging.c: Use to check the functionality of Virtual Memory Engine.<br/>
  -  s.c: The whole OS starts running from this file.<br/>
  -  Loader.c: Implement the loader.<br/>
  -  sched.c: Implement the scheduler.<br/>
  -  mem.c: Implement RAM and Virtual Memory Engine.<br/>
  -  mm.c, mm-vm.c, mm-memphy.c: Implement Paging-based Memory Management.<br/>
* Makefile
* input: Samples input used for verification
* output: Samples output of the operating system.

# How to start
To start the simulation, you must compile the source code first by using Make all command. After that, run the command:
![Screenshot 2023-11-01 105907](https://github.com/HcmutOSGroup/OS_assignment_demo/assets/109802619/e11b4295-45e6-4067-aef1-91f6ea770e14)

# Implementation
* Scheduler <br/>
  -  The OS is designed to work on multiple processors. The OS uses multiple queue called ready queue to determine which process to be executed when a CPU becomes available. Each queue is associated with a fixed priority value. The scheduler is designed based on “multilevel queue” algorithm used in Linux kernel. <br/>
  -  For each new program, the loader will create a new process and assign a new PCB to it. The loader then reads and copies the content of the program to the text segment of the new process. The PCB of the process is pushed to the associated ready queue having the same priority with the value prio of this process. Then, it waits for the CPU. The CPU runs processes in round-robin style. Each process is allowed to run in time slice. The CPU then picks up another process from ready queue and continue running. <br/>

![Screenshot 2023-11-01 105344](https://github.com/HcmutOSGroup/OS_assignment_demo/assets/109802619/f6f40b68-43ff-4218-91d9-f00d65aae7e0)

* Memory Management <br/>
  -  The virtual memory space is organized as a memory mapping for each process PCB. From the process point of view, the virtual address includes multiple vm areas (contiguously). In the real world, each area can act as code, stack or heap segment. Therefore, the process keeps in its pcb a pointer of multiple contiguous memory areas.
 
    **Memory Area** <br/>
    -  Each memory area ranges continuously in *[vm start,vm end]*. In the area between vm start and sbrk, there are multiple regions captured by struct *_vm_rg_struct_* and free slots tracking by the list *vm_freerg_list*. Through this design, we make the design to perform the actual allocation of physical memory only in the usable area.
![Screenshot 2023-11-01 110352](https://github.com/HcmutOSGroup/OS_assignment_demo/assets/109802619/905cc8b5-62aa-4c65-9dfa-d3351cf2d4d9)
    **Memory region** <br/>
    -  These regions are actually acted as the variables in the human-readable program’s source code. Due to the current out-of-scope fact, we simply touch in the concept of namespace in term of indexing. We manage them by using an array of *symrgtbl[PAGING MAX SYMTBL SZ]*. The array size is fixed by a constant, *PAGING_MAX_SYMTBL*SZ*, denoted the number of variable allowed in each program. To wrap up, we use the struct *vm_rg_struct_symrgtbl* to keep the start and the end point of the region and the pointer *rg_next* is reserved for future set tracking. <br/>

  **Memory mapping**<br/>
    -  Represented by struct mm struct, which keeps tracking of all the mentioned memory regions in a separated contiguous memory area. In each memory mapping struct, many memory areas are pointed out by struct vm area struct *mmap list. <br/>
    
  **CPU addresses** the address generated by CPU to access a specific memory location. In paging-based system, it is divided into:<br/>
    -  Page number (p): used as an index into a page table that holds the based address for each page in physical memory. <br/>
    -  Page offset (d): combined with base address to define the physical memory address that is sent to the Memory Management Unit.
   ![Screenshot 2023-11-01 111314](https://github.com/HcmutOSGroup/OS_assignment_demo/assets/109802619/4753be03-868c-4576-af61-be4981eb794f)

*  Paging-based address translation scheme <br/>
![image](https://github.com/HcmutOSGroup/OS_assignment_demo/assets/109802619/fede846c-00b0-449d-bc7c-7c3d645591d5)

*  Memory swapping <br>
    -  The swapping can help moving the contents of physical frame between the MEMRAM and MEMSWAP. The swapping is the mechanism performs the copying the frame’s content from outside to main memory ram. The swapping out, in reverse, tries to move the content of the frame in MEMRAM to MEMSWAP. In typical context, the swapping help us gain the free frame of RAM since the size of SWAP device is usually large enough.<br/>
![Screenshot 2023-11-01 112750](https://github.com/HcmutOSGroup/OS_assignment_demo/assets/109802619/4c12d215-1040-4c7f-91e0-42d6daf0cc68)
    -  **Basic memory operations in paging-based system:**
          -  **ALLOC** in most case, it fits into available region. If there is no such a suitable space, we need lift up the barrier sbrk and since it have never been touched, it may needs provide some physical frames and then map them using Page Table Entry
          -  **FREE** the storage space associated with the region id. Since we cannot collect back the taken physical frame which might cause memory holes, we just keep the collected storage space in a free list for further alloc request.
          -  **READ/WRITE** requires to get the page to be presented in the main memory. The most resource consuming step is the page swapping. If the page was in the MEMSWAP device, it needs to bring that page back to MEMRAM device (swapping in) and if it’s lack of space, we need to give back some pages to MEMSWAP device (swapping out) to make more rooms.

#  Put It All Together
![image](https://github.com/HcmutOSGroup/OS_assignment_demo/assets/109802619/850b7826-78d6-4603-b848-6f717ab4d3e3)
